use portable_atomic::{AtomicBool, AtomicPtr, AtomicU64};
use std::{ptr, sync::Arc};
use std::sync::{
    atomic::Ordering::{AcqRel, Acquire, Relaxed, Release},
    Weak,
};

use crate::{IntoF64, Key, Recorder};

/// A counter handler.
pub trait CounterFn {
    /// Increments the counter by the given amount.
    fn increment(&self, value: u64);

    /// Sets the counter to at least the given amount.
    ///
    /// This is intended to support use cases where multiple callers are attempting to synchronize
    /// this counter with an external counter that they have no control over.  As multiple callers
    /// may read that external counter, and attempt to set it here, there could be reordering issues
    /// where a caller attempts to set an older (smaller) value after the counter has been updated to
    /// the latest (larger) value.
    ///
    /// This method must cope with those cases.  An example of doing so atomically can be found in
    /// the `CounterFn` implementation for `AtomicU64`.
    fn absolute(&self, value: u64);
}

/// A gauge handler.
pub trait GaugeFn {
    /// Increments the gauge by the given amount.
    fn increment(&self, value: f64);

    /// Decrements the gauge by the given amount.
    fn decrement(&self, value: f64);

    /// Sets the gauge to the given amount.
    fn set(&self, value: f64);
}

/// A histogram handler.
pub trait HistogramFn {
    /// Records a value into the histogram.
    fn record(&self, value: f64);
}

trait AsHandle<T: ?Sized> {
    fn as_handle(&self) -> &Handle<T>;
}

enum Pointer<T: ?Sized> {
    Owned(Arc<T>),
    Remote(AtomicPtr<Weak<T>>),
}

impl<T: ?Sized> Pointer<T> {
    /// Calls the given closure with a reference to the pointee, if possible.
    ///
    /// When calling this method on a remote pointer that was never initialized, `Ok(None)` is
    /// returned specifically. Otherwise, `Ok(Some(value))` is returned if the pointee is live and a
    /// reference could be created, or `Err(())` to signal that a remote pointer is no longer live,
    /// and must be updated.
    fn try_with_ref<F, O>(&self, f: F) -> Result<Option<O>, ()>
    where
        F: Fn(&T) -> O,
    {
        match self {
            Self::Owned(owned) => Ok(Some(f(owned.as_ref()))),
            Self::Remote(remote) => {
                let weak_ptr = remote.load(Acquire);
                if weak_ptr.is_null() {
                    Ok(None)
                } else {
                    let weak = unsafe { weak_ptr.as_ref().unwrap() };
                    match weak.upgrade() {
                        Some(owned) => Ok(Some(f(owned.as_ref()))),
                        None => Err(()),
                    }
                }
            },
        }
    }

    fn update_remote(&self, new_remote: Weak<T>) {
        // Recover the old remote pointer, so that it can be dropped and allow a potential
        // allocation to be freed. We'll use `swap` to do so, so that can be avoid an invalid
        // pointer state.
        match self {
            Self::Owned(_) => unreachable!("an update should never be triggered for an owned pointer"),
            Self::Remote(remote) => {
                let new_weak_ptr = new_remote.into_raw() as *mut _;
                let old_weak_ptr = remote.swap(new_weak_ptr, AcqRel);
                drop(unsafe { Weak::from_raw(old_weak_ptr as *const _) });
            },
        }
    }
}

impl<T: ?Sized> Drop for Pointer<T> {
    fn drop(&mut self) {
        // TODO: what do we need to do here for the arc and the weak values? :thinkies:
    }
}

struct Handle<T: ?Sized> {
    key: Key,
    updating: AtomicBool,
    inner: AtomicPtr<Weak<T>>,
}

impl<T: ?Sized> Handle<T> {
    fn noop() -> Self {
        Self {
            key: Key::from_static_name(""),
            updating: AtomicBool::new(false),
            inner: AtomicPtr::new(ptr::null_mut()),
        }
    }

    fn from_arc(key: Key, inner: Weak<T>) -> Self {
        Self {
            key,
            updating: AtomicBool::new(false),
            inner: AtomicPtr::new(inner.into_raw() as *mut _),
        }
    }

    fn with_backing_storage<R, H, F, O>(&self, register: R, f: F) -> O
    where
        R: Fn(&'static dyn Recorder, &Key) -> H,
        H: AsHandle<T>,
        F: Fn(&T) -> O,
    {
        loop {
            let weak_ptr = self.inner.load(Acquire);
            if !weak_ptr.is_null() {
                // SAFETY: If `self.inner` is not a null pointer, then we know it was a valid
                // pointer generated by `Weak::into_raw`, which satisfies all the constraints of
                // `ptr::as_ref`.
                let weak = unsafe { weak_ptr.as_ref().unwrap() };
                match weak.upgrade() {
                    Some(strong) => return f(strong.as_ref()),
                    None => {
                        // Try and swap `self.updating` from `false` to `true`, meaning that we've
                        // won the race to update the underlying `Weak<T>` for this handle. If we
                        // fail at that, it means someone else is updating it and we need to spin
                        // until that happens.
                        match self.updating.compare_exchange(false, true, Release, Relaxed) {
                            Ok(false) => {
                                // Re-register the key to acquire a new `Counter`, which we'll
                                // consume to replace our innards with, giving us a new, fresh
                                // handle back to the storage.
                                if let Some(recorder) = crate::try_recorder() {
                                    let donor = register(recorder, &self.key);
                                    self.inner
                                        .store(donor.as_handle().inner.load(Acquire), Release);
                                }

                                self.updating.store(false, Release);
                            }
                            _ => {
                                while !self.updating.load(Acquire) {
                                    std::thread::yield_now();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

/// A counter.
pub struct Counter {
    inner: Handle<dyn CounterFn + Send + Sync + 'static>,
}

/// A gauge.
pub struct Gauge {
    inner: Handle<dyn GaugeFn + Send + Sync + 'static>,
}

/// A histogram.
pub struct Histogram {
    inner: Handle<dyn HistogramFn + Send + Sync + 'static>,
}

impl Counter {
    /// Creates a no-op `Counter` which does nothing.
    ///
    /// Suitable when a handle must be provided that does nothing i.e. a no-op recorder or a layer
    /// that disables specific metrics, and so on.
    pub fn noop() -> Self {
        Self { inner: Handle::noop() }
    }

    /// Creates a `Counter` based on a shared handle.
    pub fn from_arc<T: CounterFn + Send + Sync + 'static>(key: Key, inner: Weak<T>) -> Self {
        Self { inner: Handle::from_arc(key, inner) }
    }

    /// Increments the counter.
    pub fn increment(&self, value: u64) {
        self.inner.with_backing_storage(Recorder::register_counter, |inner| inner.increment(value));
    }

    /// Sets the counter to an absolute value.
    pub fn absolute(&self, value: u64) {
        self.inner.with_backing_storage(Recorder::register_counter, |inner| inner.absolute(value));
    }
}

impl AsHandle<dyn CounterFn + Send + Sync + 'static> for Counter {
    fn as_handle(&self) -> &Handle<dyn CounterFn + Send + Sync + 'static> {
        &self.inner
    }
}

impl Gauge {
    /// Creates a no-op `Gauge` which does nothing.
    ///
    /// Suitable when a handle must be provided that does nothing i.e. a no-op recorder or a layer
    /// that disables specific metrics, and so on.
    pub fn noop() -> Self {
        Self { inner: Handle::noop() }
    }

    /// Creates a `Gauge` based on a shared handle.
    pub fn from_arc<T: GaugeFn + Send + Sync + 'static>(key: Key, inner: Weak<T>) -> Self {
        Self { inner: Handle::from_arc(key, inner) }
    }

    /// Increments the gauge.
    pub fn increment<T: IntoF64>(&self, value: T) {
        let value = value.into_f64();
        self.inner.with_backing_storage(Recorder::register_gauge, |inner| inner.increment(value));
    }

    /// Decrements the gauge.
    pub fn decrement<T: IntoF64>(&self, value: T) {
        let value = value.into_f64();
        self.inner.with_backing_storage(Recorder::register_gauge, |inner| inner.decrement(value));
    }

    /// Sets the gauge.
    pub fn set<T: IntoF64>(&self, value: T) {
        let value = value.into_f64();
        self.inner.with_backing_storage(Recorder::register_gauge, |inner| inner.set(value));
    }
}

impl AsHandle<dyn GaugeFn + Send + Sync + 'static> for Gauge {
    fn as_handle(&self) -> &Handle<dyn GaugeFn + Send + Sync + 'static> {
        &self.inner
    }
}

impl Histogram {
    /// Creates a no-op `Histogram` which does nothing.
    ///
    /// Suitable when a handle must be provided that does nothing i.e. a no-op recorder or a layer
    /// that disables specific metrics, and so on.
    pub fn noop() -> Self {
        Self { inner: Handle::noop() }
    }

    /// Creates a `Histogram` based on a shared handle.
    pub fn from_arc<T: HistogramFn + Send + Sync + 'static>(key: Key, inner: Weak<T>) -> Self {
        Self { inner: Handle::from_arc(key, inner) }
    }

    /// Records a value in the histogram.
    pub fn record<T: IntoF64>(&self, value: T) {
        let value = value.into_f64();
        self.inner.with_backing_storage(Recorder::register_histogram, |inner| inner.record(value))
    }
}

impl AsHandle<dyn HistogramFn + Send + Sync + 'static> for Histogram {
    fn as_handle(&self) -> &Handle<dyn HistogramFn + Send + Sync + 'static> {
        &self.inner
    }
}

impl CounterFn for AtomicU64 {
    fn increment(&self, value: u64) {
        let _ = self.fetch_add(value, Release);
    }

    fn absolute(&self, value: u64) {
        let _ = self.fetch_max(value, AcqRel);
    }
}

impl GaugeFn for AtomicU64 {
    fn increment(&self, value: f64) {
        loop {
            let result = self.fetch_update(AcqRel, Relaxed, |curr| {
                let input = f64::from_bits(curr);
                let output = input + value;
                Some(output.to_bits())
            });

            if result.is_ok() {
                break;
            }
        }
    }

    fn decrement(&self, value: f64) {
        loop {
            let result = self.fetch_update(AcqRel, Relaxed, |curr| {
                let input = f64::from_bits(curr);
                let output = input - value;
                Some(output.to_bits())
            });

            if result.is_ok() {
                break;
            }
        }
    }

    fn set(&self, value: f64) {
        let _ = self.swap(value.to_bits(), AcqRel);
    }
}

#[cfg(feature = "std-atomics")]
impl CounterFn for std::sync::atomic::AtomicU64 {
    fn increment(&self, value: u64) {
        let _ = self.fetch_add(value, Release);
    }

    fn absolute(&self, value: u64) {
        let _ = self.fetch_max(value, AcqRel);
    }
}

#[cfg(feature = "std-atomics")]
impl GaugeFn for std::sync::atomic::AtomicU64 {
    fn increment(&self, value: f64) {
        loop {
            let result = self.fetch_update(AcqRel, Relaxed, |curr| {
                let input = f64::from_bits(curr);
                let output = input + value;
                Some(output.to_bits())
            });

            if result.is_ok() {
                break;
            }
        }
    }

    fn decrement(&self, value: f64) {
        loop {
            let result = self.fetch_update(AcqRel, Relaxed, |curr| {
                let input = f64::from_bits(curr);
                let output = input - value;
                Some(output.to_bits())
            });

            if result.is_ok() {
                break;
            }
        }
    }

    fn set(&self, value: f64) {
        let _ = self.swap(value.to_bits(), AcqRel);
    }
}
